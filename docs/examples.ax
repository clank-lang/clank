// ============================================================================
// Axon Example Programs
// ============================================================================

// ----------------------------------------------------------------------------
// Example 1: Hello World
// ----------------------------------------------------------------------------

mod hello

use std.io.println

ƒ main() → IO[()] {
  println("Hello, Axon!")
}


// ----------------------------------------------------------------------------
// Example 2: Factorial with Refinement Types
// ----------------------------------------------------------------------------

mod factorial

use std.io.println

// Note: ℕ is sugar for ℤ{x ≥ 0}
ƒ factorial(n: ℕ) → ℕ {
  if n ≤ 1 {
    1
  } else {
    n * factorial(n - 1)
  }
}

ƒ main() → IO[()] {
  println(`Factorial of 10 is ${factorial(10)}`)
}


// ----------------------------------------------------------------------------
// Example 3: Safe Division
// ----------------------------------------------------------------------------

mod division

use std.core.{Option, Some, None}
use std.io.println

// Division requires non-zero divisor
ƒ div(n: ℤ, d: ℤ{d ≠ 0}) → ℤ {
  n / d
}

// Safe wrapper that handles zero
ƒ safe_div(n: ℤ, d: ℤ) → Option[ℤ] {
  if d ≠ 0 {
    // Compiler knows d ≠ 0 in this branch
    Some(div(n, d))
  } else {
    None
  }
}

ƒ main() → IO[()] {
  // This works: compiler proves 5 ≠ 0
  let result1 = div(10, 5)
  println(`10 / 5 = ${result1}`)
  
  // This requires the safe wrapper
  let user_input = get_user_number()  // Returns ℤ
  match safe_div(100, user_input) {
    Some(r) → println(`100 / input = ${r}`),
    None → println("Cannot divide by zero!")
  }
}

external ƒ get_user_number() → IO[ℤ] = "getUserNumber"


// ----------------------------------------------------------------------------
// Example 4: Vector Operations with Length Tracking
// ----------------------------------------------------------------------------

mod vectors

use std.core.{Option, Some, None}

// Head requires non-empty array
ƒ head[T](arr: [T]{len(arr) > 0}) → T {
  arr[0]
}

// Safe head for any array
ƒ safe_head[T](arr: [T]) → Option[T] {
  if len(arr) > 0 {
    Some(head(arr))
  } else {
    None
  }
}

// Map preserves length
ƒ map[T, U](arr: [T], f: (T) → U) → [U] {
  let mut result: [U] = []
  for x in arr {
    result = push(result, f(x))
  }
  result
}

// Filter may reduce length
ƒ filter[T](arr: [T], pred: (T) → Bool) → [T] {
  let mut result: [T] = []
  for x in arr {
    if pred(x) {
      result = push(result, x)
    }
  }
  result
}

ƒ main() → IO[()] {
  let numbers = [1, 2, 3, 4, 5]
  
  // This is safe: literal array is non-empty
  let first = head(numbers)
  
  // Double all numbers
  let doubled = map(numbers, λx → x * 2)
  
  // Filter evens - result might be empty
  let evens = filter(numbers, λx → x % 2 == 0)
  
  // Must use safe_head since filter may return empty
  match safe_head(evens) {
    Some(e) → println(`First even: ${e}`),
    None → println("No evens found")
  }
}


// ----------------------------------------------------------------------------
// Example 5: Result Type and Error Handling
// ----------------------------------------------------------------------------

mod errors

use std.core.{Result, Ok, Err}
use std.io.{read_file, println}

sum ParseError {
  InvalidFormat(line: ℤ),
  MissingField(name: Str)
}

sum AppError {
  Io(msg: Str),
  Parse(ParseError)
}

rec Config {
  host: Str,
  port: ℤ{port > 0 ∧ port < 65536}
}

ƒ parse_config(content: Str) → Err[ParseError, Config] {
  // Simplified parsing logic
  let lines = split(content, "\n")
  
  let host = find_field(lines, "host")?  // Propagates error
  let port_str = find_field(lines, "port")?
  
  match parse_int(port_str) {
    Some(p) → {
      if p > 0 ∧ p < 65536 {
        Ok(Config { host: host, port: p })
      } else {
        Err(InvalidFormat(0))
      }
    },
    None → Err(InvalidFormat(0))
  }
}

ƒ load_config(path: Str) → IO + Err[AppError, Config] {
  let content = read_file(path)
    |> map_err(λe → Io(e.message))?
  
  parse_config(content)
    |> map_err(λe → Parse(e))
}

ƒ main() → IO[()] {
  match load_config("config.txt") {
    Ok(cfg) → println(`Loaded config: ${cfg.host}:${cfg.port}`),
    Err(e) → println(`Error loading config: ${show(e)}`)
  }
}


// ----------------------------------------------------------------------------
// Example 6: External JS Interop
// ----------------------------------------------------------------------------

mod interop

use std.io.println

// Declare external functions
external ƒ now() → ℤ = "Date.now"
external ƒ random() → ℝ{r ≥ 0 ∧ r < 1} = "Math.random"

// External module
external mod lodash = "lodash" {
  ƒ chunk[T](arr: [T], size: ℤ{size > 0}) → [[T]]
  ƒ shuffle[T](arr: [T]) → [T]
  ƒ uniq[T](arr: [T]) → [T]
}

use external lodash

ƒ main() → IO[()] {
  let timestamp = now()
  println(`Current timestamp: ${timestamp}`)
  
  let r = random()
  println(`Random number: ${r}`)
  
  let numbers = [1, 2, 2, 3, 3, 3, 4]
  let unique = lodash.uniq(numbers)
  println(`Unique: ${unique}`)
  
  let chunked = lodash.chunk([1, 2, 3, 4, 5, 6], 2)
  println(`Chunked: ${chunked}`)
}


// ----------------------------------------------------------------------------
// Example 7: Async Operations
// ----------------------------------------------------------------------------

mod async_example

use std.async.{sleep, parallel}
use std.io.println

ƒ fetch_data(url: Str) → Async + Err[HttpError, Str] {
  // Simulated async fetch
  sleep(100)
  Ok(`Data from ${url}`)
}

ƒ main() → Async + IO[()] {
  // Sequential
  let data1 = fetch_data("https://api.example.com/1")?
  println(data1)
  
  // Parallel
  let results = parallel([
    fetch_data("https://api.example.com/a"),
    fetch_data("https://api.example.com/b"),
    fetch_data("https://api.example.com/c")
  ])
  
  for r in results {
    match r {
      Ok(data) → println(data),
      Err(e) → println(`Error: ${e}`)
    }
  }
}


// ----------------------------------------------------------------------------
// Example 8: Linear Types (Resource Management)
// ----------------------------------------------------------------------------

mod resources

use std.io.{println, IO}

// File handle is a linear resource
external ƒ open_file(path: Str) → IO + Err[IoError, Linear[FileHandle]] = "Bun.file"
external ƒ read_all(h: Linear[FileHandle]) → IO[(Str, Linear[FileHandle])] = "readAll"
external ƒ close_file(h: Linear[FileHandle]) → IO[()] = "closeFile"

ƒ process_file(path: Str) → IO + Err[IoError, Str] {
  let handle = open_file(path)?
  let (content, handle) = read_all(handle)
  close_file(handle)  // Must consume the handle
  Ok(content)
}

ƒ main() → IO[()] {
  match process_file("data.txt") {
    Ok(content) → println(content),
    Err(e) → println(`Error: ${e}`)
  }
}


// ----------------------------------------------------------------------------
// Example 9: Pre/Post Conditions
// ----------------------------------------------------------------------------

mod contracts

use std.core.Option

// Binary search with contracts
ƒ binary_search[T: Ord](arr: [T], target: T) → Option[ℕ{i < len(arr)}]
  pre is_sorted(arr)
  post match result {
    Some(i) → arr[i] == target,
    None → ¬contains(arr, target)
  }
{
  if len(arr) == 0 {
    return None
  }
  
  let mut low: ℕ = 0
  let mut high: ℕ = len(arr) - 1
  
  while low ≤ high {
    let mid = low + (high - low) / 2
    
    if arr[mid] == target {
      return Some(mid)
    } else if arr[mid] < target {
      low = mid + 1
    } else {
      if mid == 0 {
        break
      }
      high = mid - 1
    }
  }
  
  None
}

// Insertion sort with postcondition
ƒ sort[T: Ord](arr: [T]) → [T]
  post is_sorted(result) ∧ len(result) == len(arr)
{
  let mut result = arr
  for i in 1..len(result) {
    let key = result[i]
    let mut j = i - 1
    while j >= 0 ∧ result[j] > key {
      result[j + 1] = result[j]
      j = j - 1
    }
    result[j + 1] = key
  }
  result
}


// ----------------------------------------------------------------------------
// Example 10: Pattern Matching
// ----------------------------------------------------------------------------

mod patterns

use std.io.println

sum Json {
  Null,
  Bool(Bool),
  Number(ℝ),
  String(Str),
  Array([Json]),
  Object(Map[Str, Json])
}

ƒ json_type(j: Json) → Str {
  match j {
    Null → "null",
    Bool(_) → "boolean",
    Number(_) → "number",
    String(_) → "string",
    Array(_) → "array",
    Object(_) → "object"
  }
}

ƒ json_get(j: Json, key: Str) → Option[Json] {
  match j {
    Object(m) → m.get(key),
    _ → None
  }
}

// Nested pattern matching
ƒ extract_name(j: Json) → Option[Str] {
  match j {
    Object(m) → match m.get("name") {
      Some(String(s)) → Some(s),
      _ → None
    },
    _ → None
  }
}

// Guard patterns
ƒ classify_number(n: ℤ) → Str {
  match n {
    0 → "zero",
    n if n > 0 → "positive",
    _ → "negative"
  }
}


// ----------------------------------------------------------------------------
// Example 11: Pipelines
// ----------------------------------------------------------------------------

mod pipelines

use std.collections.{map, filter, fold}
use std.io.println

rec Person {
  name: Str,
  age: ℤ{age ≥ 0}
}

ƒ main() → IO[()] {
  let people = [
    Person { name: "Alice", age: 30 },
    Person { name: "Bob", age: 25 },
    Person { name: "Charlie", age: 35 },
    Person { name: "Diana", age: 28 }
  ]
  
  // Pipeline: filter adults, get names, join
  let adult_names = people
    |> filter(λp → p.age ≥ 30)
    |> map(λp → p.name)
    |> join(", ")
  
  println(`Adults: ${adult_names}`)
  
  // Calculate average age
  let total_age = people
    |> map(λp → p.age)
    |> fold(0, λacc, age → acc + age)
  
  let avg_age = total_age / len(people)
  println(`Average age: ${avg_age}`)
}


// ----------------------------------------------------------------------------
// Example 12: Type-Level Bounded Integers
// ----------------------------------------------------------------------------

mod bounded

use std.core.Option

// Port number type: 1-65535
type Port = ℤ{p > 0 ∧ p < 65536}

// HTTP status code categories
type InfoStatus = ℤ{s ≥ 100 ∧ s < 200}
type SuccessStatus = ℤ{s ≥ 200 ∧ s < 300}
type RedirectStatus = ℤ{s ≥ 300 ∧ s < 400}
type ClientErrorStatus = ℤ{s ≥ 400 ∧ s < 500}
type ServerErrorStatus = ℤ{s ≥ 500 ∧ s < 600}
type HttpStatus = ℤ{s ≥ 100 ∧ s < 600}

ƒ is_success(status: HttpStatus) → Bool {
  status ≥ 200 ∧ status < 300
}

// Create a port from user input
ƒ make_port(n: ℤ) → Option[Port] {
  if n > 0 ∧ n < 65536 {
    Some(n)  // Compiler proves refinement
  } else {
    None
  }
}

rec ServerConfig {
  host: Str,
  port: Port,
  max_connections: ℤ{c > 0}
}

ƒ create_server(host: Str, port_num: ℤ) → Option[ServerConfig] {
  match make_port(port_num) {
    Some(p) → Some(ServerConfig {
      host: host,
      port: p,
      max_connections: 100
    }),
    None → None
  }
}
