{
  "$comment": "Example showing a complete agent workflow with repairs",
  "$description": "This file demonstrates the iterative repair cycle that agents use with the Clank compiler. It shows: (1) Initial broken program, (2) Compiler response with repairs, (3) Applied repair, (4) Final success.",

  "workflow_steps": [
    {
      "step": 1,
      "description": "Agent submits initial program with errors",
      "input": {
        "kind": "program",
        "declarations": [
          {
            "kind": "fn",
            "name": "require_positive",
            "id": "fn_1",
            "typeParams": [],
            "params": [
              {
                "name": "n",
                "id": "param_1",
                "type": {
                  "kind": "refined",
                  "base": { "kind": "named", "name": "Int" },
                  "varName": "n",
                  "predicate": {
                    "kind": "binary",
                    "op": ">",
                    "left": { "kind": "ident", "name": "n" },
                    "right": { "kind": "literal", "value": { "kind": "int", "value": "0" } }
                  }
                }
              }
            ],
            "returnType": { "kind": "named", "name": "Int" },
            "body": { "kind": "ident", "name": "n" }
          },
          {
            "kind": "fn",
            "name": "caller",
            "id": "fn_2",
            "typeParams": [],
            "params": [
              {
                "name": "x",
                "id": "param_2",
                "type": { "kind": "named", "name": "Int" }
              }
            ],
            "returnType": { "kind": "named", "name": "Int" },
            "body": {
              "kind": "call",
              "id": "call_1",
              "callee": { "kind": "ident", "name": "require_positive" },
              "args": [{ "kind": "ident", "name": "x", "id": "arg_1" }]
            }
          }
        ]
      }
    },
    {
      "step": 2,
      "description": "Compiler responds with error and repair candidates",
      "compile_result": {
        "status": "error",
        "canonical_ast": {
          "$comment": "Same as input but with node IDs assigned"
        },
        "diagnostics": [
          {
            "id": "d1",
            "code": "E3001",
            "severity": "error",
            "message": "Cannot prove refinement 'x > 0' at call to 'require_positive'",
            "primary_node_id": "arg_1",
            "structured": {
              "predicate": "x > 0",
              "context": "argument to require_positive"
            },
            "repair_refs": ["rc1", "rc2", "rc3"]
          }
        ],
        "obligations": [
          {
            "id": "obl1",
            "kind": "refinement",
            "predicate": "x > 0",
            "location": { "node_id": "arg_1" },
            "solverResult": "unknown",
            "counterexample": {
              "x": "-1",
              "_explanation": "x = -1 would violate 'x > 0'"
            },
            "repair_refs": ["rc1", "rc2", "rc3"]
          }
        ],
        "repairs": [
          {
            "id": "rc1",
            "title": "Add guard: if x > 0 { ... }",
            "confidence": "high",
            "safety": "likely_preserving",
            "kind": "local_fix",
            "scope": { "node_count": 2, "crosses_function": false },
            "targets": {
              "node_ids": ["call_1"],
              "obligation_ids": ["obl1"]
            },
            "edits": [
              {
                "op": "wrap",
                "node_id": "call_1",
                "wrapper": {
                  "kind": "if",
                  "condition": { "source": "x > 0" },
                  "thenBranch": { "kind": "block", "statements": [], "expr": { "$hole": "original" } },
                  "elseBranch": { "kind": "block", "statements": [], "expr": { "source": "0" } }
                },
                "hole_ref": "original"
              }
            ],
            "expected_delta": {
              "diagnostics_resolved": ["d1"],
              "obligations_discharged": ["obl1"]
            },
            "rationale": "Adding a guard ensures x > 0 is known in the then-branch"
          },
          {
            "id": "rc2",
            "title": "Refine parameter: x: Int{x > 0}",
            "confidence": "medium",
            "safety": "behavior_changing",
            "kind": "semantics_change",
            "scope": { "node_count": 1, "crosses_function": false },
            "targets": {
              "node_ids": ["param_2"],
              "obligation_ids": ["obl1"]
            },
            "edits": [
              {
                "op": "replace_node",
                "node_id": "param_2",
                "new_node": {
                  "name": "x",
                  "type": {
                    "kind": "refined",
                    "base": { "kind": "named", "name": "Int" },
                    "varName": "x",
                    "predicate": { "source": "x > 0" }
                  }
                }
              }
            ],
            "expected_delta": {
              "diagnostics_resolved": ["d1"],
              "obligations_discharged": ["obl1"]
            },
            "rationale": "Pushes proof obligation to callers"
          },
          {
            "id": "rc3",
            "title": "Add assertion: assert x > 0",
            "confidence": "medium",
            "safety": "likely_preserving",
            "kind": "boundary_validation",
            "scope": { "node_count": 1, "crosses_function": false },
            "targets": {
              "node_ids": ["call_1"],
              "obligation_ids": ["obl1"]
            },
            "edits": [
              {
                "op": "insert_before",
                "target_id": "call_1",
                "new_statement": {
                  "kind": "assert",
                  "condition": { "source": "x > 0" },
                  "message": "x must be positive"
                }
              }
            ],
            "expected_delta": {
              "diagnostics_resolved": ["d1"],
              "obligations_discharged": ["obl1"]
            },
            "rationale": "Runtime check + establishes fact for solver"
          }
        ],
        "output": null
      }
    },
    {
      "step": 3,
      "description": "Agent selects repair rc1 (highest confidence, behavior-preserving) and applies it",
      "agent_action": {
        "repair_selected": "rc1",
        "reasoning": "rc1 has high confidence and is likely_preserving (safe to apply automatically)"
      },
      "fixed_ast": {
        "kind": "program",
        "declarations": [
          {
            "kind": "fn",
            "name": "require_positive",
            "id": "fn_1",
            "typeParams": [],
            "params": [
              {
                "name": "n",
                "id": "param_1",
                "type": {
                  "kind": "refined",
                  "base": { "kind": "named", "name": "Int" },
                  "varName": "n",
                  "predicate": {
                    "kind": "binary",
                    "op": ">",
                    "left": { "kind": "ident", "name": "n" },
                    "right": { "kind": "literal", "value": { "kind": "int", "value": "0" } }
                  }
                }
              }
            ],
            "returnType": { "kind": "named", "name": "Int" },
            "body": { "kind": "ident", "name": "n" }
          },
          {
            "kind": "fn",
            "name": "caller",
            "id": "fn_2",
            "typeParams": [],
            "params": [
              {
                "name": "x",
                "id": "param_2",
                "type": { "kind": "named", "name": "Int" }
              }
            ],
            "returnType": { "kind": "named", "name": "Int" },
            "body": {
              "kind": "if",
              "id": "if_1",
              "condition": {
                "kind": "binary",
                "op": ">",
                "left": { "kind": "ident", "name": "x" },
                "right": { "kind": "literal", "value": { "kind": "int", "value": "0" } }
              },
              "thenBranch": {
                "kind": "block",
                "statements": [],
                "expr": {
                  "kind": "call",
                  "id": "call_1",
                  "callee": { "kind": "ident", "name": "require_positive" },
                  "args": [{ "kind": "ident", "name": "x", "id": "arg_1" }]
                }
              },
              "elseBranch": {
                "kind": "block",
                "statements": [],
                "expr": { "kind": "literal", "value": { "kind": "int", "value": "0" } }
              }
            }
          }
        ]
      }
    },
    {
      "step": 4,
      "description": "Agent resubmits fixed program, compiler succeeds",
      "compile_result": {
        "status": "success",
        "diagnostics": [],
        "obligations": [
          {
            "id": "obl1",
            "kind": "refinement",
            "predicate": "x > 0",
            "solverResult": "discharged",
            "$comment": "Branch condition x > 0 is now known in the then-branch"
          }
        ],
        "repairs": [],
        "output": {
          "js": "function require_positive(n) {\n  return n;\n}\n\nfunction caller(x) {\n  return (x > 0n) ? require_positive(x) : 0n;\n}\n"
        }
      }
    }
  ],

  "agent_best_practices": {
    "repair_selection_priority": [
      "1. Filter repairs: only 'behavior_preserving' or 'likely_preserving'",
      "2. Sort by: confidence (high > medium > low)",
      "3. Prefer: local_fix > refactor > semantics_change",
      "4. Apply top repair and recompile"
    ],
    "when_to_apply_behavior_changing": [
      "Only when explicitly requested by user",
      "Or when no behavior_preserving repairs available"
    ],
    "handling_unknown_solver_results": [
      "Check for counterexamples - they show concrete failures",
      "Add guards or assertions to establish facts",
      "Restructure code to help solver"
    ]
  }
}
