// ============================================================================
// Refinement Type Examples
// ============================================================================
// Clank supports refinement types that constrain values with predicates.
// The compiler's solver attempts to prove predicates statically, and
// generates counterexamples when it can refute them.

// ----------------------------------------------------------------------------
// Basic Refinement Types
// ----------------------------------------------------------------------------

// Positive integers: Int{x > 0}
fn require_positive(n: Int{n > 0}) -> Int {
  n
}

// Non-zero integers for multiplication (division returns Float)
fn safe_multiply(a: Int, b: Int{b != 0}) -> Int {
  a * b
}

// Bounded integers
fn percentage(p: Int{p >= 0 && p <= 100}) -> Int {
  p
}

// ----------------------------------------------------------------------------
// Calling Refined Functions
// ----------------------------------------------------------------------------

// Literal arguments: compiler proves 42 > 0
fn use_literal() -> Int {
  require_positive(42)
}

// Variables need guards to satisfy refinements
fn use_guarded(x: Int) -> Int {
  if x > 0 {
    // Compiler knows x > 0 in this branch
    require_positive(x)
  } else {
    0
  }
}

// Parameter refinements propagate into function body
fn already_positive(n: Int{n > 0}) -> Int {
  // No guard needed: n > 0 is known
  require_positive(n)
}

// ----------------------------------------------------------------------------
// Array Length Refinements
// ----------------------------------------------------------------------------

// Non-empty array type: [T]{len(arr) > 0}
fn head[T](arr: [T]{len(arr) > 0}) -> T {
  arr[0]  // Safe: solver proves 0 < len(arr)
}

// Safe head that handles empty arrays
fn safe_head[T](arr: [T]) -> Option[T] {
  if len(arr) > 0 {
    // Compiler knows len(arr) > 0 here
    Some(head(arr))
  } else {
    None
  }
}

// Bounded array access
fn safe_get[T](arr: [T], i: Int{i >= 0 && i < len(arr)}) -> T {
  arr[i]  // Safe: bounds are in the refinement
}

// ----------------------------------------------------------------------------
// Arithmetic Reasoning
// ----------------------------------------------------------------------------

// The solver understands arithmetic relationships
fn arithmetic_proof(n: Int{n > 0}) -> Int {
  let m = n + 1;
  // Solver proves: n > 0 implies n + 1 > 1 implies m > 0
  require_positive(m)
}

// Transitive comparisons
fn transitive_example(x: Int{x > 5}) -> Int {
  // Solver knows: x > 5 implies x > 0
  require_positive(x)
}

// ----------------------------------------------------------------------------
// Conditional Facts
// ----------------------------------------------------------------------------

// If-conditions create facts in branches
fn branch_facts(x: Int, y: Int) -> Int {
  if x > 0 {
    if y > 0 {
      // Both x > 0 and y > 0 are known here
      x + y
    } else {
      x
    }
  } else {
    0
  }
}

// Match arms create facts too
fn match_facts(x: Int) -> Int {
  match x > 0 {
    true ->require_positive(x),  // x > 0 known
    false ->0
  }
}

// ----------------------------------------------------------------------------
// Assertions
// ----------------------------------------------------------------------------

// Assert establishes facts for the solver and creates runtime checks
fn assert_example(x: Int) -> Int {
  assert x > 0 : "x must be positive";
  // After assert, solver knows x > 0
  require_positive(x)
}

// Assert without message
fn process_validated(input: Int) -> Int {
  assert input >= 0 && input <= 100;
  input * 2
}

// ----------------------------------------------------------------------------
// Counterexamples
// ----------------------------------------------------------------------------

// When a refinement cannot be proven, the compiler generates counterexamples
// showing concrete values that would violate the predicate.
//
// Example error output:
//
// fn bad_call(x: Int) -> Int {
//   require_positive(x)  // Error E3001
// }
//
// Diagnostic:
// {
//   "code": "E3001",
//   "message": "Cannot prove refinement 'x > 0'",
//   "counterexample": { "x": "-1", "_violated": "x > 0" },
//   "repair_refs": ["rc1", "rc2"]
// }
//
// The counterexample shows x = -1 is a value that would violate the refinement.

// ----------------------------------------------------------------------------
// Solver Limits
// ----------------------------------------------------------------------------

// The built-in solver handles:
// - Linear arithmetic (a + b > c)
// - Simple comparisons and logical operators
// - Function calls to len() and other known functions
// - Facts established by guards and assertions
//
// For complex predicates, the solver may return "unknown" instead of
// proving or disproving. In these cases, use assert or restructure code.
