/**
 * End-to-end compilation tests
 *
 * Tests the full compilation pipeline from Axon source to JavaScript.
 */

import { describe, test, expect } from "bun:test";
import { tokenize } from "../../src/lexer";
import { parse } from "../../src/parser";
import { typecheck } from "../../src/types";
import { emit } from "../../src/codegen";
import { SourceFile } from "../../src/utils/source";

// =============================================================================
// Test Helpers
// =============================================================================

interface CompileTestResult {
  success: boolean;
  code?: string;
  errors: string[];
}

function compileSource(source: string): CompileTestResult {
  const sourceFile = new SourceFile("<test>", source);

  // Lex
  const { tokens, errors: lexErrors } = tokenize(sourceFile);
  if (lexErrors.length > 0) {
    return {
      success: false,
      errors: lexErrors.map((e) => `Lex error: ${e.message}`),
    };
  }

  // Parse
  const { program, errors: parseErrors } = parse(tokens);
  if (parseErrors.length > 0) {
    return {
      success: false,
      errors: parseErrors.map((e) => `Parse error: ${e.message}`),
    };
  }

  // Type check
  const { diagnostics } = typecheck(program);
  const typeErrors = diagnostics.filter((d) => d.severity === "error");
  if (typeErrors.length > 0) {
    return {
      success: false,
      errors: typeErrors.map((e) => `Type error: ${e.message}`),
    };
  }

  // Code generation
  const { code } = emit(program);

  return {
    success: true,
    code,
    errors: [],
  };
}

/**
 * Compile and run Axon code by writing to a temp file and importing it.
 * This is safe because we only execute code generated by our own compiler.
 */
async function compileAndRun(source: string): Promise<unknown> {
  const result = compileSource(source);
  if (!result.success) {
    throw new Error(`Compilation failed: ${result.errors.join(", ")}`);
  }

  // Write to temp file with main() call appended
  const tempPath = `/tmp/axon-test-${Date.now()}-${Math.random().toString(36).slice(2)}.mjs`;
  const codeWithExport = result.code + "\nexport const __result = typeof main === 'function' ? main() : undefined;\n";
  await Bun.write(tempPath, codeWithExport);

  try {
    const module = await import(tempPath);
    return module.__result;
  } finally {
    // Clean up temp file
    await Bun.file(tempPath).exists() && (await import("fs/promises")).unlink(tempPath).catch(() => {});
  }
}

// =============================================================================
// Compilation Tests
// =============================================================================

describe("E2E: Compilation", () => {
  test("compiles empty program", () => {
    const result = compileSource("");
    expect(result.success).toBe(true);
    expect(result.code).toBeDefined();
  });

  test("compiles simple function", () => {
    const result = compileSource(`
      fn add(a: Int, b: Int) -> Int {
        a + b
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("function add");
  });

  test("compiles let binding", () => {
    const result = compileSource(`
      fn main() -> Int {
        let x = 42;
        x
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("const x");
  });

  test("compiles conditional expression", () => {
    const result = compileSource(`
      fn max(a: Int, b: Int) -> Int {
        if a > b { a } else { b }
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("?");
  });

  test("compiles lambda expression", () => {
    const result = compileSource(`
      fn main() -> Int {
        let double = \\(x: Int) -> x * 2;
        double(21)
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("=>");
  });

  test("compiles tuple literal", () => {
    const result = compileSource(`
      fn pair() -> (Int, Int) {
        (1, 2)
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("[");
  });

  test("compiles array literal", () => {
    const result = compileSource(`
      fn numbers() -> [Int] {
        [1, 2, 3]
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("[1n, 2n, 3n]");
  });

  test("compiles record type declaration", () => {
    const result = compileSource(`
      rec Point { x: Int, y: Int }

      fn get_x(p: Point) -> Int {
        p.x
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("function get_x");
  });

  test("compiles type alias", () => {
    const result = compileSource(`
      type MyInt = Int

      fn double(n: MyInt) -> MyInt {
        n * 2
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("function double");
  });

  test("compiles sum type", () => {
    const result = compileSource(`
      sum Shape { Circle(Int), Rectangle(Int, Int) }

      fn area(s: Shape) -> Int {
        match s {
          Circle(r) -> r * r * 3,
          Rectangle(w, h) -> w * h,
        }
      }
    `);
    expect(result.success).toBe(true);
  });
});

// =============================================================================
// Execution Tests
// =============================================================================

describe("E2E: Execution", () => {
  test("executes arithmetic", async () => {
    const result = await compileAndRun(`
      fn main() -> Int {
        let a = 10;
        let b = 20;
        a + b
      }
    `);
    expect(result).toBe(30n);
  });

  test("executes function calls", async () => {
    const result = await compileAndRun(`
      fn square(n: Int) -> Int {
        n * n
      }

      fn main() -> Int {
        square(7)
      }
    `);
    expect(result).toBe(49n);
  });

  test("executes conditionals", async () => {
    const result = await compileAndRun(`
      fn abs(n: Int) -> Int {
        if n < 0 { -n } else { n }
      }

      fn main() -> Int {
        abs(-42)
      }
    `);
    expect(result).toBe(42n);
  });

  test("executes lambdas", async () => {
    const result = await compileAndRun(`
      fn main() -> Int {
        let double = \\(x: Int) -> x * 2;
        double(21)
      }
    `);
    expect(result).toBe(42n);
  });

  test("executes tuple destructuring", async () => {
    const result = await compileAndRun(`
      fn main() -> Int {
        let pair = (10, 32);
        let (a, b) = pair;
        a + b
      }
    `);
    expect(result).toBe(42n);
  });

  test("executes tuple indexing", async () => {
    const result = await compileAndRun(`
      fn main() -> Int {
        let triple = (3, 4, 5);
        let (a, b, c) = triple;
        a + b + c
      }
    `);
    expect(result).toBe(12n);
  });

  test("executes nested function calls", async () => {
    const result = await compileAndRun(`
      fn add(a: Int, b: Int) -> Int { a + b }
      fn mul(a: Int, b: Int) -> Int { a * b }

      fn main() -> Int {
        mul(add(2, 3), add(4, 6))
      }
    `);
    expect(result).toBe(50n);
  });

  test("executes recursive function", async () => {
    const result = await compileAndRun(`
      fn factorial(n: Int) -> Int {
        if n <= 1 { 1 } else { n * factorial(n - 1) }
      }

      fn main() -> Int {
        factorial(5)
      }
    `);
    expect(result).toBe(120n);
  });

  test("executes fibonacci", async () => {
    const result = await compileAndRun(`
      fn fib(n: Int) -> Int {
        if n <= 1 { n } else { fib(n - 1) + fib(n - 2) }
      }

      fn main() -> Int {
        fib(10)
      }
    `);
    expect(result).toBe(55n);
  });
});

// =============================================================================
// Error Tests
// =============================================================================

describe("E2E: Error Detection", () => {
  test("reports syntax errors", () => {
    const result = compileSource(`
      fn main( -> Int { 42 }
    `);
    expect(result.success).toBe(false);
    expect(result.errors.length).toBeGreaterThan(0);
  });

  test("reports type errors for mismatched return", () => {
    const result = compileSource(`
      fn main() -> Int {
        "hello"
      }
    `);
    expect(result.success).toBe(false);
    expect(result.errors.some((e) => e.includes("Type error"))).toBe(true);
  });

  test("reports type errors for undefined variable", () => {
    const result = compileSource(`
      fn main() -> Int {
        undefined_var
      }
    `);
    expect(result.success).toBe(false);
    expect(result.errors.some((e) => e.includes("error"))).toBe(true);
  });

  test("reports type errors for wrong argument count", () => {
    const result = compileSource(`
      fn add(a: Int, b: Int) -> Int { a + b }

      fn main() -> Int {
        add(1)
      }
    `);
    expect(result.success).toBe(false);
  });

  test("reports type errors for wrong argument type", () => {
    const result = compileSource(`
      fn double(n: Int) -> Int { n * 2 }

      fn main() -> Int {
        double("hello")
      }
    `);
    expect(result.success).toBe(false);
  });
});

// =============================================================================
// Code Generation Quality Tests
// =============================================================================

describe("E2E: Code Quality", () => {
  test("generates BigInt for integer literals", () => {
    const result = compileSource(`
      fn main() -> Int { 42 }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("42n");
  });

  test("generates runtime for Option/Result types", () => {
    const result = compileSource(`
      fn maybe() -> Option[Int] {
        Some(42)
      }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("__axon");
  });

  test("includes runtime helpers", () => {
    const result = compileSource(`
      fn main() -> Int { 42 }
    `);
    expect(result.success).toBe(true);
    expect(result.code).toContain("const __axon");
  });
});
