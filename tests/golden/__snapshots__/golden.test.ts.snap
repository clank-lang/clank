// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`Golden: 01-data-structures compiles valid application to TypeScript: data-structures-ts 1`] = `
"// Clank Runtime Types

/** Option type - represents an optional value */
type Option<T> = { tag: "Some"; value: T } | { tag: "None" };

/** Result type - represents success or failure */
type Result<T, E> = { tag: "Ok"; value: T } | { tag: "Err"; error: E };

/** Ordering type - result of comparison */
type Ordering = { tag: "Less" } | { tag: "Equal" } | { tag: "Greater" };

/** Clank runtime interface */
interface ClankRuntime {
  // Option constructors
  Some<T>(value: T): Option<T>;
  None: Option<never>;

  // Result constructors
  Ok<T>(value: T): Result<T, never>;
  Err<E>(error: E): Result<never, E>;

  // Ordering values
  Less: Ordering;
  Equal: Ordering;
  Greater: Ordering;

  // Pattern matching
  match<T, R>(value: T, cases: Record<string, (payload?: unknown) => R>): R;

  // Assertions
  assert(condition: boolean, message?: string): void;
  panic(message: string): never;
  unreachable(): never;

  // Range
  range(start: bigint, end: bigint, inclusive: boolean): bigint[];

  // Array helpers
  len<T>(arr: T[]): bigint;
  is_empty<T>(arr: T[]): boolean;
  push<T>(arr: T[], item: T): T[];
  map<T, U>(arr: T[], fn: (item: T) => U): U[];
  filter<T>(arr: T[], pred: (item: T) => boolean): T[];
  fold<T, U>(arr: T[], init: U, fn: (acc: U, item: T) => U): U;
  get<T>(arr: T[], idx: bigint): Option<T>;
  find<T>(arr: T[], pred: (item: T) => boolean): Option<T>;
  any<T>(arr: T[], pred: (item: T) => boolean): boolean;
  all<T>(arr: T[], pred: (item: T) => boolean): boolean;
  contains<T>(arr: T[], elem: T): boolean;
  concat<T>(a: T[], b: T[]): T[];
  reverse<T>(arr: T[]): T[];
  take<T>(arr: T[], n: bigint): T[];
  drop<T>(arr: T[], n: bigint): T[];
  zip<T, U>(a: T[], b: U[]): [T, U][];

  // String helpers
  str_len(s: string): bigint;
  trim(s: string): string;
  split(s: string, delim: string): string[];
  join(parts: string[], delim: string): string;
  to_string(x: unknown): string;

  // IO helpers
  print(s: string): void;
  println(s: string): void;

  // Math helpers
  abs(n: bigint): bigint;
  min<T>(a: T, b: T): T;
  max<T>(a: T, b: T): T;

  // Type conversion
  int_to_float(n: bigint): number;
  float_to_int(x: number): bigint;
}

declare const __clank: ClankRuntime;


interface Person {
  name: string;
  age: bigint;
}

function Person(name: string, age: bigint): Person {
  return { name, age };
}

type Status =
  | { tag: "Active" }
  | { tag: "Inactive"; reason: string }
  | { tag: "Pending"; days_remaining: bigint };

const Active: Status = Object.freeze({ tag: "Active" });
function Inactive(reason: string): Status {
  return { tag: "Inactive", reason };
}
function Pending(days_remaining: bigint): Status {
  return { tag: "Pending", days_remaining };
}

function describe_person(p: Person): string {
  return ((p.name + " is ") + __clank.to_string(p.age));
}

function is_active(status: Status): boolean {
  return __clank.match(status, { Active: () => true, Inactive: (_) => false, Pending: (_) => false });
}

function days_until_active(status: Status): bigint {
  return __clank.match(status, { Active: () => 0n, Inactive: (_) => -1n, Pending: (days) => days });
}
"
`;

exports[`Golden: 02-algorithms-refinements compiles valid application to TypeScript: algorithms-refinements-ts 1`] = `
"// Clank Runtime Types

/** Option type - represents an optional value */
type Option<T> = { tag: "Some"; value: T } | { tag: "None" };

/** Result type - represents success or failure */
type Result<T, E> = { tag: "Ok"; value: T } | { tag: "Err"; error: E };

/** Ordering type - result of comparison */
type Ordering = { tag: "Less" } | { tag: "Equal" } | { tag: "Greater" };

/** Clank runtime interface */
interface ClankRuntime {
  // Option constructors
  Some<T>(value: T): Option<T>;
  None: Option<never>;

  // Result constructors
  Ok<T>(value: T): Result<T, never>;
  Err<E>(error: E): Result<never, E>;

  // Ordering values
  Less: Ordering;
  Equal: Ordering;
  Greater: Ordering;

  // Pattern matching
  match<T, R>(value: T, cases: Record<string, (payload?: unknown) => R>): R;

  // Assertions
  assert(condition: boolean, message?: string): void;
  panic(message: string): never;
  unreachable(): never;

  // Range
  range(start: bigint, end: bigint, inclusive: boolean): bigint[];

  // Array helpers
  len<T>(arr: T[]): bigint;
  is_empty<T>(arr: T[]): boolean;
  push<T>(arr: T[], item: T): T[];
  map<T, U>(arr: T[], fn: (item: T) => U): U[];
  filter<T>(arr: T[], pred: (item: T) => boolean): T[];
  fold<T, U>(arr: T[], init: U, fn: (acc: U, item: T) => U): U;
  get<T>(arr: T[], idx: bigint): Option<T>;
  find<T>(arr: T[], pred: (item: T) => boolean): Option<T>;
  any<T>(arr: T[], pred: (item: T) => boolean): boolean;
  all<T>(arr: T[], pred: (item: T) => boolean): boolean;
  contains<T>(arr: T[], elem: T): boolean;
  concat<T>(a: T[], b: T[]): T[];
  reverse<T>(arr: T[]): T[];
  take<T>(arr: T[], n: bigint): T[];
  drop<T>(arr: T[], n: bigint): T[];
  zip<T, U>(a: T[], b: U[]): [T, U][];

  // String helpers
  str_len(s: string): bigint;
  trim(s: string): string;
  split(s: string, delim: string): string[];
  join(parts: string[], delim: string): string;
  to_string(x: unknown): string;

  // IO helpers
  print(s: string): void;
  println(s: string): void;

  // Math helpers
  abs(n: bigint): bigint;
  min<T>(a: T, b: T): T;
  max<T>(a: T, b: T): T;

  // Type conversion
  int_to_float(n: bigint): number;
  float_to_int(x: number): bigint;
}

declare const __clank: ClankRuntime;


function safe_first(arr: bigint[]): bigint {
  return arr[0n];
}

function safe_get(arr: bigint[], i: bigint): bigint {
  return arr[i];
}

function requires_positive(n: bigint): bigint {
  return (n * 2n);
}

function call_with_increment(n: bigint): bigint {
  return requires_positive((n + 1n));
}
"
`;

exports[`Golden: 03-effects-errors compiles valid application to TypeScript: effects-errors-ts 1`] = `
"// Clank Runtime Types

/** Option type - represents an optional value */
type Option<T> = { tag: "Some"; value: T } | { tag: "None" };

/** Result type - represents success or failure */
type Result<T, E> = { tag: "Ok"; value: T } | { tag: "Err"; error: E };

/** Ordering type - result of comparison */
type Ordering = { tag: "Less" } | { tag: "Equal" } | { tag: "Greater" };

/** Clank runtime interface */
interface ClankRuntime {
  // Option constructors
  Some<T>(value: T): Option<T>;
  None: Option<never>;

  // Result constructors
  Ok<T>(value: T): Result<T, never>;
  Err<E>(error: E): Result<never, E>;

  // Ordering values
  Less: Ordering;
  Equal: Ordering;
  Greater: Ordering;

  // Pattern matching
  match<T, R>(value: T, cases: Record<string, (payload?: unknown) => R>): R;

  // Assertions
  assert(condition: boolean, message?: string): void;
  panic(message: string): never;
  unreachable(): never;

  // Range
  range(start: bigint, end: bigint, inclusive: boolean): bigint[];

  // Array helpers
  len<T>(arr: T[]): bigint;
  is_empty<T>(arr: T[]): boolean;
  push<T>(arr: T[], item: T): T[];
  map<T, U>(arr: T[], fn: (item: T) => U): U[];
  filter<T>(arr: T[], pred: (item: T) => boolean): T[];
  fold<T, U>(arr: T[], init: U, fn: (acc: U, item: T) => U): U;
  get<T>(arr: T[], idx: bigint): Option<T>;
  find<T>(arr: T[], pred: (item: T) => boolean): Option<T>;
  any<T>(arr: T[], pred: (item: T) => boolean): boolean;
  all<T>(arr: T[], pred: (item: T) => boolean): boolean;
  contains<T>(arr: T[], elem: T): boolean;
  concat<T>(a: T[], b: T[]): T[];
  reverse<T>(arr: T[]): T[];
  take<T>(arr: T[], n: bigint): T[];
  drop<T>(arr: T[], n: bigint): T[];
  zip<T, U>(a: T[], b: U[]): [T, U][];

  // String helpers
  str_len(s: string): bigint;
  trim(s: string): string;
  split(s: string, delim: string): string[];
  join(parts: string[], delim: string): string;
  to_string(x: unknown): string;

  // IO helpers
  print(s: string): void;
  println(s: string): void;

  // Math helpers
  abs(n: bigint): bigint;
  min<T>(a: T, b: T): T;
  max<T>(a: T, b: T): T;

  // Type conversion
  int_to_float(n: bigint): number;
  float_to_int(x: number): bigint;
}

declare const __clank: ClankRuntime;


function log_message(msg: string): void {
  return __clank.println(msg);
}

function parse_positive(n: bigint): Result<bigint, string> {
  return ((n <= 0n) ? __clank.Err("must be positive") : __clank.Ok(n));
}

function process_with_logging(x: bigint): bigint {
  log_message("Processing...");
  return (x * 2n);
}
"
`;

exports[`Golden: 04-generics-hof compiles valid application to TypeScript: generics-hof-ts 1`] = `
"// Clank Runtime Types

/** Option type - represents an optional value */
type Option<T> = { tag: "Some"; value: T } | { tag: "None" };

/** Result type - represents success or failure */
type Result<T, E> = { tag: "Ok"; value: T } | { tag: "Err"; error: E };

/** Ordering type - result of comparison */
type Ordering = { tag: "Less" } | { tag: "Equal" } | { tag: "Greater" };

/** Clank runtime interface */
interface ClankRuntime {
  // Option constructors
  Some<T>(value: T): Option<T>;
  None: Option<never>;

  // Result constructors
  Ok<T>(value: T): Result<T, never>;
  Err<E>(error: E): Result<never, E>;

  // Ordering values
  Less: Ordering;
  Equal: Ordering;
  Greater: Ordering;

  // Pattern matching
  match<T, R>(value: T, cases: Record<string, (payload?: unknown) => R>): R;

  // Assertions
  assert(condition: boolean, message?: string): void;
  panic(message: string): never;
  unreachable(): never;

  // Range
  range(start: bigint, end: bigint, inclusive: boolean): bigint[];

  // Array helpers
  len<T>(arr: T[]): bigint;
  is_empty<T>(arr: T[]): boolean;
  push<T>(arr: T[], item: T): T[];
  map<T, U>(arr: T[], fn: (item: T) => U): U[];
  filter<T>(arr: T[], pred: (item: T) => boolean): T[];
  fold<T, U>(arr: T[], init: U, fn: (acc: U, item: T) => U): U;
  get<T>(arr: T[], idx: bigint): Option<T>;
  find<T>(arr: T[], pred: (item: T) => boolean): Option<T>;
  any<T>(arr: T[], pred: (item: T) => boolean): boolean;
  all<T>(arr: T[], pred: (item: T) => boolean): boolean;
  contains<T>(arr: T[], elem: T): boolean;
  concat<T>(a: T[], b: T[]): T[];
  reverse<T>(arr: T[]): T[];
  take<T>(arr: T[], n: bigint): T[];
  drop<T>(arr: T[], n: bigint): T[];
  zip<T, U>(a: T[], b: U[]): [T, U][];

  // String helpers
  str_len(s: string): bigint;
  trim(s: string): string;
  split(s: string, delim: string): string[];
  join(parts: string[], delim: string): string;
  to_string(x: unknown): string;

  // IO helpers
  print(s: string): void;
  println(s: string): void;

  // Math helpers
  abs(n: bigint): bigint;
  min<T>(a: T, b: T): T;
  max<T>(a: T, b: T): T;

  // Type conversion
  int_to_float(n: bigint): number;
  float_to_int(x: number): bigint;
}

declare const __clank: ClankRuntime;


interface Pair<A, B> {
  first: A;
  second: B;
}

function Pair<A, B>(first: A, second: B): Pair<A, B> {
  return { first, second };
}

function identity<T>(x: T): T {
  return x;
}

function make_pair<A, B>(a: A, b: B): Pair<A, B> {
  return Pair(a, b);
}

function apply_fn<A, B>(f: (arg0: A) => B, x: A): B {
  return f(x);
}

function map_option<A, B>(opt: A | null, f: (arg0: A) => B): B | null {
  return __clank.match(opt, { Some: (x) => __clank.Some(f(x)), None: () => __clank.None });
}

function add(a: bigint, b: bigint): bigint {
  return (a + b);
}
"
`;

exports[`Golden: 05-interop compiles valid application to TypeScript: interop-ts 1`] = `
"// Clank Runtime Types

/** Option type - represents an optional value */
type Option<T> = { tag: "Some"; value: T } | { tag: "None" };

/** Result type - represents success or failure */
type Result<T, E> = { tag: "Ok"; value: T } | { tag: "Err"; error: E };

/** Ordering type - result of comparison */
type Ordering = { tag: "Less" } | { tag: "Equal" } | { tag: "Greater" };

/** Clank runtime interface */
interface ClankRuntime {
  // Option constructors
  Some<T>(value: T): Option<T>;
  None: Option<never>;

  // Result constructors
  Ok<T>(value: T): Result<T, never>;
  Err<E>(error: E): Result<never, E>;

  // Ordering values
  Less: Ordering;
  Equal: Ordering;
  Greater: Ordering;

  // Pattern matching
  match<T, R>(value: T, cases: Record<string, (payload?: unknown) => R>): R;

  // Assertions
  assert(condition: boolean, message?: string): void;
  panic(message: string): never;
  unreachable(): never;

  // Range
  range(start: bigint, end: bigint, inclusive: boolean): bigint[];

  // Array helpers
  len<T>(arr: T[]): bigint;
  is_empty<T>(arr: T[]): boolean;
  push<T>(arr: T[], item: T): T[];
  map<T, U>(arr: T[], fn: (item: T) => U): U[];
  filter<T>(arr: T[], pred: (item: T) => boolean): T[];
  fold<T, U>(arr: T[], init: U, fn: (acc: U, item: T) => U): U;
  get<T>(arr: T[], idx: bigint): Option<T>;
  find<T>(arr: T[], pred: (item: T) => boolean): Option<T>;
  any<T>(arr: T[], pred: (item: T) => boolean): boolean;
  all<T>(arr: T[], pred: (item: T) => boolean): boolean;
  contains<T>(arr: T[], elem: T): boolean;
  concat<T>(a: T[], b: T[]): T[];
  reverse<T>(arr: T[]): T[];
  take<T>(arr: T[], n: bigint): T[];
  drop<T>(arr: T[], n: bigint): T[];
  zip<T, U>(a: T[], b: U[]): [T, U][];

  // String helpers
  str_len(s: string): bigint;
  trim(s: string): string;
  split(s: string, delim: string): string[];
  join(parts: string[], delim: string): string;
  to_string(x: unknown): string;

  // IO helpers
  print(s: string): void;
  println(s: string): void;

  // Math helpers
  abs(n: bigint): bigint;
  min<T>(a: T, b: T): T;
  max<T>(a: T, b: T): T;

  // Type conversion
  int_to_float(n: bigint): number;
  float_to_int(x: number): bigint;
}

declare const __clank: ClankRuntime;


function console_log(msg: string): void {
  return console.log(msg);
}

function date_now(): bigint {
  return Date.now();
}

function parse_int(s: string): bigint {
  return parseInt(s);
}

function log_timestamp(): void {
  const ts = date_now();
  return console_log(__clank.to_string(ts));
}

function parse_and_double(s: string): bigint {
  const n = parse_int(s);
  return (n * 2n);
}
"
`;
